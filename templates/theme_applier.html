<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ThemeQR – Theme & Deck Manager</title>
  <link rel="stylesheet" href="/static/css/theme_applier.css">
  <link rel="icon" href="https://themeqr.com/images/TQR_Dude_Sm.png">
</head>
<body>
<header>
  <h1>ThemeQR: Theme & Deck Manager</h1>
  <p>Manage your themes and decks effortlessly.</p>
  <div class="header-bottom">
    <nav class="header-nav">
      <a href="/manager">Manager</a> |
      <a href="/themes">Themes</a> |
      <a href="/decks">Decks</a>
    </nav>
    <div class="auth-controls">
      <span>Hello, mrsbdkelmon@gmail.com!</span>
      <a href="/logout" class="logout-btn">Log Out</a>
    </div>
  </div>
</header>

<div class="main-panel">
  <h2>QR Code Preview</h2>
  <div id="qrPreview" class="qr-preview">
    <img id="qrImg" class="qr" src="" alt="QR Code" style="display: none;">
  </div>
</div>

<!-- NEW: Create Deck Panel -->
<div class="create-deck card">
<h2>Create Deck</h2>
<label for="newDeckName" class="label">Deck Name</label>
<input id="newDeckName" class="input" type="text" placeholder="Deck Name" />
<button id="createDeckBtn" class="apply-btn" style="margin-top:8px;">Create</button>
<div id="createDeckStatus" class="status" style="margin-top:6px; display:none;"></div>
<hr style="margin:14px 0; opacity:.2;">
</div>

<div class="container">

    
  <div class="left-panel">
    <h2>Your Decks</h2>
    <div id="deckContainer" class="grid"></div>
  </div>
  <div class="right-panel">
    <h2>Available Themes</h2>
    <div id="themeContainer" class="grid"></div>
  </div>
</div>

<div id="loadingIndicator" class="loading" style="display:none;">Loading data...</div>
<div id="errorDisplay" class="error" style="display:none;">Error: <span id="errorMessage"></span></div>

<footer class="footer">
  &copy; 2025 ThemeQR. All rights reserved.
</footer>

<script type="module">
  import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm";

  const SUPABASE_URL = "https://hvfqdrfdefgfqbfdikpn.supabase.co";
  const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imh2ZnFkcmZkZWZnZnFiZmRpa3BuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTIxOTA4MjgsImV4cCI6MjA2Nzc2NjgyOH0.nG8rzVCQR6J8XxbTaiC9zOUjFu7fi-4oRVY-D61NCJU";
  const VAULT_ID = "6d570fa1-9ae3-4ecb-82d5-e1494ae3e404";

  console.log("Supabase URL:", SUPABASE_URL);
  console.log("Supabase Key:", SUPABASE_KEY ? "Set" : "Not set");
  console.log("Vault ID:", VAULT_ID);

  let supabase = null;
  try {
      if (SUPABASE_URL && SUPABASE_URL.startsWith('http') && SUPABASE_KEY) {
          supabase = createClient(SUPABASE_URL, SUPABASE_KEY);
          console.log("Supabase client initialized successfully.");
      } else {
          throw new Error("Supabase URL or Key is invalid or missing.");
      }
  } catch (e) {
      document.getElementById('errorMessage').textContent = `Failed to initialize Supabase: ${e.message}`;
      document.getElementById('errorDisplay').style.display = '';
      console.error("Supabase initialization failed:", e);
  }

  const deckContainer = document.getElementById('deckContainer');
  const themeContainer = document.getElementById('themeContainer');
  const qrImg = document.getElementById('qrImg');
  const loadingIndicator = document.getElementById('loadingIndicator');
  const errorDisplay = document.getElementById('errorDisplay');
  const errorMessageSpan = document.getElementById('errorMessage');
  const newDeckNameInput = document.getElementById('newDeckName');
  const createDeckBtn = document.getElementById('createDeckBtn');
  const createDeckStatus = document.getElementById('createDeckStatus'); 


  let allThemes = [];
  let allDecks = [];
  let selectedDeckId = null;

  function showLoading(show) {
      loadingIndicator.style.display = show ? '' : 'none';
      errorDisplay.style.display = 'none';
  }

  function showError(message) {
      errorMessageSpan.textContent = message;
      errorDisplay.style.display = '';
      showLoading(false);
  }

  async function fetchDataFromSupabase(tableName, filter = {}) {
      if (!supabase) {
          showError("Supabase client not initialized.");
          return [];
      }
      try {
          let query = supabase.from(tableName).select('*');
          if (filter.vault_id && filter.vault_id !== "None") {
              console.log("Fetching with vault_id:", filter.vault_id);
              query = query.eq('vault_id', filter.vault_id);
          }
          const { data, error } = await query;
          if (error) throw new Error(error.message);
          console.log(`Fetched ${tableName}:`, data);
          return data || [];
      } catch (error) {
          showError(`Failed to fetch ${tableName}: ${error.message}`);
          return [];
      }
  }

function populateDecks(decks) {
  deckContainer.innerHTML = '';
  if (!decks.length) {
    deckContainer.innerHTML = '<p style="color:#666;">No decks found.</p>';
    return;
  }

  decks.forEach(deck => {
    const deckDiv = document.createElement('div');
    deckDiv.classList.add('theme-item'); // reuse theme card styling for symmetry
    deckDiv.style.cursor = 'pointer';
    deckDiv.dataset.deckId = deck.id;

    const hasVideo = deck.wrapper && deck.wrapper.startsWith('http');
    const hasLanding = deck.landing_url && deck.landing_url.startsWith('http');

    // Build video area (like themes)
    const videoSectionHTML = hasVideo
      ? `
        <div class="video-wrapper">
          <div class="video-section">
            <video id="deck-video-${deck.id}" class="theme-video" width="200" height="150"
                   style="display:none;" muted playsinline controls preload="metadata">
            </video>
            <div id="deck-novideo-${deck.id}" class="no-video" style="display:none; color:red;">No Video</div>
          </div>
          <div class="button-section">
            ${hasLanding
              ? `<a class="apply-btn" href="${deck.landing_url}" target="_blank" rel="noopener">Landing page</a>`
              : `<span class="no-video" style="color:#666;">No landing page</span>`}
          </div>
        </div>`
      : `
        <div class="video-wrapper">
          <div class="video-section">
            <div id="deck-novideo-${deck.id}" class="no-video" style="display:block; color:red;">No Video</div>
          </div>
          <div class="button-section">
            ${hasLanding
              ? `<a class="apply-btn" href="${deck.landing_url}" target="_blank" rel="noopener">Landing page</a>`
              : `<span class="no-video" style="color:#666;">No landing page</span>`}
          </div>
        </div>`;

    deckDiv.innerHTML = `
      <div class="theme-header">
        <span class="theme-name">${deck.deck_name || deck.id.slice(0,8)}</span>
      </div>
      ${videoSectionHTML}
    `;

    // Click selects the deck (for QR overlay/apply)
    deckDiv.addEventListener('click', (e) => {
      // Don’t hijack clicks on the Landing page link
      if (e.target && e.target.tagName === 'A') return;
      selectDeck(deck.id);
    });

    deckContainer.appendChild(deckDiv);

    // Wire up video only if we have one
    if (hasVideo) {
      const videoEl = document.getElementById(`deck-video-${deck.id}`);
      const noVideoEl = document.getElementById(`deck-novideo-${deck.id}`);

      videoEl.addEventListener('error', () => {
        videoEl.style.display = 'none';
        if (noVideoEl) noVideoEl.style.display = 'block';
      }, { once: true });

      videoEl.addEventListener('canplay', () => {
        videoEl.style.display = 'block';
        if (noVideoEl) noVideoEl.style.display = 'none';
        videoEl.play().catch(() => {});
      }, { once: true });

      // Set src after listeners are attached
      videoEl.src = deck.wrapper;
    }
  });
}

async function refreshDecks() {
  if (!VAULT_ID || VAULT_ID === "None") return;
  const { data, error } = await supabase
    .from('decks')
    .select('*')
    .eq('vault_id', VAULT_ID)
    .order('created_at', { ascending: false });

  if (error) {
    showError(`Failed to refresh decks: ${error.message}`);
    return;
  }
  allDecks = data || [];
  populateDecks(allDecks);
}

function populateThemes(themes) {
  themeContainer.innerHTML = '';
  if (themes.length === 0) {
    themeContainer.innerHTML = '<p style="color:#666;">No themes found.</p>';
    return;
  }

  themes.forEach(theme => {
    const themeDiv = document.createElement('div');
    themeDiv.classList.add('theme-item');

    const videoContent = theme.wrapper_url.includes('player.cloudinary.com')
      ? `
        <div class="video-wrapper">
          <div class="video-section">
            <iframe id="video-${theme.id}" class="theme-video" width="200" height="150"
                    src="${theme.wrapper_url}"
                    frameborder="0"
                    allow="autoplay; encrypted-media"
                    allowfullscreen
                    style="display:block;">
            </iframe>
          </div>
          <div class="button-section">
            <button class="apply-btn" data-theme-id="${theme.id}">Apply</button>
          </div>
        </div>`
      : `
        <div class="video-wrapper">
          <div class="video-section">
            <!-- NOTE: no <source> tag; we set .src in JS -->
            <video id="video-${theme.id}" class="theme-video" width="200" height="150"
                   style="display:none;"
                   muted
                   playsinline
                   controls
                   preload="metadata">
            </video>
            <div id="no-video-${theme.id}" class="no-video" style="display:none; color:red;">No Video</div>
          </div>
          <div class="button-section">
            <button class="apply-btn" data-theme-id="${theme.id}">Apply</button>
          </div>
        </div>`;

    themeDiv.innerHTML = `
      <div class="theme-header">
        <span class="theme-name">${theme.name}</span>
      </div>
      ${videoContent}
    `;
    themeContainer.appendChild(themeDiv);

    const applyButton = themeDiv.querySelector('.apply-btn');
    if (applyButton) {
      applyButton.addEventListener('click', () => applyTheme(theme.id));
    }

    // Only wire up <video> if we're not using the Cloudinary player iframe
    if (!theme.wrapper_url.includes('player.cloudinary.com')) {
      const video = document.getElementById(`video-${theme.id}`);
      const noVideo = document.getElementById(`no-video-${theme.id}`);

      video.addEventListener('error', () => {
        video.style.display = 'none';
        noVideo.style.display = 'block';
      }, { once: true });

      // Show once it can play; start playback once
      video.addEventListener('canplay', () => {
        video.style.display = 'block';
        noVideo.style.display = 'none';
        // Optional smooth looping:
        // video.loop = true;
        video.play().catch(() => {/* autoplay may be blocked if not muted */});
      }, { once: true });

      // Set src AFTER attributes are in place
      video.src = theme.wrapper_url;
    }
  });
}

function selectDeck(deckId) {
  selectedDeckId = deckId;
  const selectedDeck = allDecks.find(d => d.id === deckId);
  if (!selectedDeck) return;

  // Preferred: use Cloudinary URL saved in DB
  const cloudQr = (selectedDeck.qr_code || '').trim();

  if (cloudQr && cloudQr.startsWith('http')) {
    // Cloudinary (or any remote) QR url
    qrImg.src = `${cloudQr}${cloudQr.includes('?') ? '&' : '?'}t=${Date.now()}`;
    qrImg.style.display = 'block';
    console.log("Selected deck:", deckId, "QR displayed (cloud):", qrImg.src);
    return;
  }

  // Fallback to legacy local file pattern ONLY if no qr_code url
  const deckName = (selectedDeck.deck_name || '').trim();
  if (!deckName) {
    qrImg.style.display = 'none';
    console.warn("No deck_name or qr_code; nothing to show.");
    return;
  }

  const qrImageName = `${VAULT_ID}_${deckName}_qr.png`;
  const localUrl = `https://themeqr-backend.onrender.com/static/${encodeURIComponent(qrImageName)}?t=${Date.now()}`;

  qrImg.src = localUrl;
  qrImg.style.display = 'block';
  console.log("Selected deck:", deckId, "QR displayed (local):", qrImg.src);
}

async function applyTheme(themeId) {
  if (!selectedDeckId) {
    showError("Please select a deck first.");
    return;
  }
  showLoading(true);
  try {
    const theme = allThemes.find(t => t.id === themeId);
    if (!theme) throw new Error("Theme not found.");

    // ✅ Declare variables BEFORE fetch options
    const selectedDeck = allDecks.find(d => d.id === selectedDeckId);
    const qrUrlForServer =
      (selectedDeck?.qr_code && selectedDeck.qr_code.startsWith('http'))
        ? selectedDeck.qr_code
        : (qrImg.src || '').split('?')[0]; // strip cache-buster

    const payload = {
      deck_id: selectedDeckId,
      theme_id: themeId,
      qr_url: qrUrlForServer
    };

    const response = await fetch('/apply_theme', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    if (!response.ok) {
      // Try to surface the server message
      let msg = `HTTP error! Status: ${response.status}`;
      try {
        const err = await response.json();
        if (err?.error) msg = err.error;
      } catch {}
      throw new Error(msg);
    }

    const result = await response.json();

    if (result.success) {
      // reflect new wrapper + landing in local cache
      const updatedDeck = allDecks.find(d => d.id === selectedDeckId);
      if (updatedDeck) {
        updatedDeck.wrapper = result.new_wrapper_url;
        updatedDeck.landing_url = theme.landing_url;
      }
      await refreshDecks();
      selectDeck(selectedDeckId);
      errorMessageSpan.textContent = "Theme applied successfully!";
      errorDisplay.style.color = 'green';
      errorDisplay.style.display = '';
    } else {
      showError(result.error || "Failed to apply theme.");
    }
  } catch (error) {
    showError(`Error applying theme: ${error.message}`);
  } finally {
    showLoading(false);
  }
}


  function setCreateStatus(msg, kind = 'info') {
  if (!createDeckStatus) return;
  createDeckStatus.style.display = msg ? '' : 'none';
  createDeckStatus.style.color = (kind === 'error') ? 'crimson' : (kind === 'success') ? 'green' : '#555';
  createDeckStatus.textContent = msg || '';
}

async function createDeck() {
  try {
    if (!supabase) throw new Error("Supabase client not initialized.");
    if (!VAULT_ID || VAULT_ID === "None") throw new Error("No vault_id available.");
    const name = (newDeckNameInput.value || '').trim();
    if (!name) {
      setCreateStatus("Enter a deck name.", 'error');
      return;
    }

    // Disable button during work
    createDeckBtn.disabled = true;
    setCreateStatus("Creating deck…");

    // 1) Insert new deck row
    const newId = (crypto && crypto.randomUUID) ? crypto.randomUUID() : `${Date.now()}-${Math.random().toString(16).slice(2)}`;
    const { data: inserted, error: insertErr } = await supabase
      .from('decks')
      .insert([{
        id: newId,
        vault_id: VAULT_ID,
        deck_name: name,
        qr_code: '',        // initially blank
        wrapper: '',        // initially blank
        landing_url: ''     // initially blank
      }])
      .select();

    if (insertErr) throw new Error(`Insert failed: ${insertErr.message}`);
    if (!inserted || !inserted.length) throw new Error("Insert returned no rows.");

    // 2) Build landing URL for this deck
    const landingUrl = `https://www.themeqr.com/go.html/?id=${newId}`;

    setCreateStatus("Generating QR…");

    // 3) Ask backend to generate QR (and upload to Cloudinary) for that landing URL
    const qrResp = await fetch('/generate_qr', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ link: landingUrl })
    });
    if (!qrResp.ok) {
      const err = await qrResp.json().catch(() => ({}));
      throw new Error(`QR generation failed: ${err.error || qrResp.statusText}`);
    }
    const qrJson = await qrResp.json();
    if (!qrJson.success || !qrJson.qr_url) throw new Error("QR response missing URL.");
    const cloudQrUrl = qrJson.qr_url;

    setCreateStatus("Saving QR & landing to deck…");

    // 4) Update the new deck with QR URL and landing URL
    const { data: updated, error: updErr } = await supabase
      .from('decks')
      .update({ qr_code: cloudQrUrl })
      .eq('id', newId)       // safer than eq('landing_url',...)
      .select();

    if (updErr) throw new Error(`Update failed: ${updErr.message}`);

    setCreateStatus("Deck created!", 'success');

    // 5) Refresh local list and auto-select the new deck
    // Pull the fresh row (or just push a local object if you want)
    const { data: newDeckRow } = await supabase
      .from('decks')
      .select('*')
      .eq('id', newId)
      .single();

    if (newDeckRow) {
      allDecks.unshift(newDeckRow);
      populateDecks(allDecks);
      // Clear box, select the new one and show its QR
      newDeckNameInput.value = '';
      selectDeck(newId);
    }
  } catch (e) {
    console.error(e);
    setCreateStatus(e.message || "Failed to create deck.", 'error');
  } finally {
    createDeckBtn.disabled = false;
  }
}



  document.addEventListener('DOMContentLoaded', async () => {
      showLoading(true);
      try {
          allThemes = await fetchDataFromSupabase('themes');
          populateThemes(allThemes);
          if (VAULT_ID && VAULT_ID !== "None") {
              console.log("Using vault_id:", VAULT_ID);
              allDecks = await fetchDataFromSupabase('decks', { vault_id: VAULT_ID });
              populateDecks(allDecks);
          } else {
              deckContainer.innerHTML = '<p style="color:#666;">No vault assigned. Please ensure you are logged in and contact support.</p>';
              console.warn("VAULT_ID is invalid or missing:", VAULT_ID);
          }
      } catch (e) {
          showError(`Failed to load initial data: ${e.message}`);
      } finally {
          showLoading(false);
      }

      if (createDeckBtn) {
       createDeckBtn.addEventListener('click', createDeck);
     } 
  });
</script>
</body>
</html>