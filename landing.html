<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>QR Landing</title>
    <style>
      :root {
        --bg1: #101635;
        --bg2: #0b0f23;
        --fg: #f3f6ff;
        --cta-bg: #6c7dff;
        --cta-fg: #09122a;
        --font: Inter, system-ui, -apple-system, Segoe UI, Roboto,
          "Helvetica Neue", Arial, "Noto Sans";
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        margin: 0;
        color: var(--fg);
        font-family: var(--font);
        background: linear-gradient(140deg, var(--bg1), var(--bg2));
        display: grid;
        min-height: 100vh;
        grid-template-rows: auto 1fr auto;
      }
      header,
      footer {
        padding: 14px 18px;
        opacity: 0.9;
      }
      header {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: conic-gradient(from 200deg, #6c7dff, #2de6c5);
      }
      main {
        display: grid;
        grid-template-columns: minmax(280px, 860px);
        justify-content: center;
        padding: 14px;
      }
      .card {
        background: rgba(6, 9, 24, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 14px;
        overflow: hidden;
        backdrop-filter: saturate(110%) blur(8px);
      }
      /* Key fix: clamp height so media never gets too tall */
      .media {
        background: #070a18;
        position: relative;
      }
      .media img,
      .media video {
        display: block;
        width: 100%;
        height: auto;
        object-fit: contain; /* fit inside the box, don't crop */
      }

      .media .placeholder {
        padding: 40px 12px;
        text-align: center;
        color: #bac2ffb3;
      }
      .content {
        padding: 16px;
      }
      h1 {
        margin: 0 0 6px 0;
      }
      .muted {
        color: #bac2ffb3;
      }
      .cta {
        display: inline-block;
        margin-top: 10px;
        padding: 11px 16px;
        border-radius: 12px;
        background: var(--cta-bg);
        color: var(--cta-fg);
        text-decoration: none;
        font-weight: 700;
        box-shadow: 0 6px 20px rgba(108, 125, 255, 0.3);
      }
      .small {
        font-size: 12px;
      }

      /* Live landing QR overlay */
      .qr-overlay {
        position: absolute;
        left: 16px;
        top: 16px;
        width: 160px;
        height: 160px;
        display: grid;
        place-items: center;
        z-index: 5;
        opacity: 1;
        -webkit-user-drag: none;
        user-select: none;
        -webkit-user-select: none;
        pointer-events: auto;
      }
    </style>
  </head>
  <body>
    <header>
      <div class="dot"></div>
      <div class="muted small">QR Landing</div>
    </header>
    <main>
      <div class="card">
        <div class="media" id="media">
          <div class="muted">No media in theme.</div>
        </div>
        <div class="content">
          <h1 id="title">Hello ðŸ‘‹</h1>
          <div id="subtitle" class="muted">Welcome!</div>
          <a id="cta" class="cta" href="#" target="_blank" rel="noopener"
            >Learn more</a
          >
          <div id="note" class="small muted" style="margin-top: 10px"></div>
        </div>
      </div>
    </main>
    <footer class="small muted" id="foot">Powered by ThemeQR</footer>

    <!-- QRCode CDN for live overlay -->
    <script src="https://unpkg.com/qrcode@1.5.3/build/qrcode.min.js"></script>

    <script type="module">
      import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";
      const sb = createClient(
        "https://YOUR-PROJECT.supabase.co",
        "YOUR_PUBLIC_ANON_KEY"
      );

      async function fetchThemeById(id) {
        // numeric check
        if (!/^\d+$/.test(String(id))) return null;
        const { data, error } = await sb
          .from("themes")
          .select("*")
          .eq("id", id)
          .maybeSingle();
        if (error || !data) return null;
        // Your schema stores the full JSON split across columns
        return {
          id, // remote id
          name: data.name,
          title: data.title,
          subtitle: data.subtitle,
          font: data.font,
          colors: data.colors || {},
          cta: data.cta || {},
          media: data.media || {},
          // settings werenâ€™t in your tableâ€”keep defaults if missing:
          settings: data.settings || {
            redirectDelay: 2,
            showSkip: true,
            skipText: "Skip",
          },
        };
      }

      async function loadData() {
        // 1) localStorage first (desktop dev)
        let themes = null,
          links = null;
        try {
          themes = JSON.parse(localStorage.getItem("qrstudio.themes"));
        } catch {}
        try {
          links = JSON.parse(localStorage.getItem("qrstudio.links"));
        } catch {}

        // 2) Supabase theme by numeric themeId (works on phones)
        let theme = null;
        if (themeId) theme = await fetchThemeById(themeId);

        // 3) Hosted JSON fallback
        if (!Array.isArray(themes)) {
          try {
            const r = await fetch("/qrstudio-themes.json", {
              cache: "no-store",
            });
            themes = (await r.json())?.themes ?? [];
          } catch {}
        }
        if (!Array.isArray(links)) {
          try {
            const r = await fetch("/qrstudio-links.json", {
              cache: "no-store",
            });
            links = (await r.json())?.links ?? [];
          } catch {}
        }

        return { themes, links, theme };
      }

      (async () => {
        const { themes, links, theme } = await loadData();
        // prefer Supabase theme if available, else use themeId/links mapping from local/JSON
        let chosenTheme = theme;
        if (!chosenTheme) {
          const explicit = themeId
            ? (themes || []).find((t) => (t.remoteId ?? t.id) == themeId)
            : null;
          const link = linkId
            ? (links || []).find((l) => l.id === linkId)
            : null;
          const byLink = link?.themeId
            ? (themes || []).find((t) => (t.remoteId ?? t.id) == link.themeId)
            : null;
          chosenTheme = explicit || byLink || null;
        }
        // â€¦applyTheme(chosenTheme) and resolveLink(link) as you already doâ€¦
      })();

      async function loadDataViaSupabase(linkId, themeId) {
        if (!window.sb) return null;

        let link = null;
        if (linkId) {
          const { data, error } = await sb
            .from("links")
            .select("*")
            .eq("id", linkId)
            .maybeSingle();
          if (!error) link = data;
        }

        let theme = null;
        const resolvedThemeId = themeId || link?.theme_id;
        if (resolvedThemeId) {
          // If you stored full theme under themes.data (json)
          const { data, error } = await sb
            .from("themes")
            .select("*")
            .eq("id", resolvedThemeId)
            .maybeSingle();
          if (!error && data) {
            theme = data.data || data; // use data.data when your JSON is in a 'data' column
          }
        }

        // Return in the same shape Studio expects
        const themes = theme ? [theme] : [];
        const links = link
          ? [{ id: link.id, url: link.url, themeId: link.theme_id }]
          : [];

        return { themes, links };
      }

      // Replace your loadData() with a fallback chain:
      // 1) localStorage â†’ 2) Supabase â†’ 3) hosted JSON files
      async function loadData() {
        const qs = new URLSearchParams(location.search);
        const linkId = qs.get("linkId") || "";
        const themeId = qs.get("themeId") || "";
        const isNumericId = (v) => /^\d+$/.test(String(v || ""));
        // 1) localStorage
        let themes = store.get("qrstudio.themes");
        let links = store.get("qrstudio.links");
        if (Array.isArray(themes) && Array.isArray(links))
          return { themes, links };

        // 2) Supabase
        const sbData = await loadDataViaSupabase(linkId, themeId);
        if (sbData && (sbData.themes.length || sbData.links.length))
          return sbData;

        // 3) Hosted JSON
        const j1 = await fetchJson("/qrstudio-themes.json");
        const j2 = await fetchJson("/qrstudio-links.json");
        return { themes: j1?.themes ?? [], links: j2?.links ?? [] };
      }

      function normalizeHttpUrl(input) {
        if (!input) return "";
        const u = String(input).trim();
        if (u.startsWith("//")) return "https:" + u;
        if (/^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(u)) return u;
        return "https://" + u.replace(/^\/+/, "");
      }

      // Map Studio preview width â†’ a sensible vh; final size is clamped in CSS
      function computeMediaVh(theme) {
        const w = Number(theme?.settings?.mediaBox?.w || 0);
        if (w && w <= 320) return 34;
        if (w && w <= 420) return 38;
        if (w && w <= 520) return 42;
        return 46; // slightly smaller default
      }

      const store = {
        get(key) {
          try {
            return JSON.parse(localStorage.getItem(key));
          } catch {
            return null;
          }
        },
      };

      async function fetchFallback(path) {
        try {
          const r = await fetch(path, { cache: "no-store" });
          if (!r.ok) return null;
          return await r.json();
        } catch {
          return null;
        }
      }
      async function loadData() {
        let themes = store.get("qrstudio.themes");
        let links = store.get("qrstudio.links");
        if (!themes) {
          const j = await fetchFallback("./qrstudio-themes.json");
          themes = j?.themes ?? [];
        }
        if (!links) {
          const j = await fetchFallback("./qrstudio-links.json");
          links = j?.links ?? [];
        }
        return { themes, links };
      }

      function applyTheme(theme) {
        if (!theme) return;
        const root = document.documentElement.style;
        root.setProperty("--bg1", theme.colors?.bg1 || "#101635");
        root.setProperty("--bg2", theme.colors?.bg2 || "#0b0f23");
        root.setProperty("--fg", theme.colors?.fg || "#f3f6ff");
        root.setProperty("--cta-bg", theme.colors?.ctaBg || "#6c7dff");
        root.setProperty("--cta-fg", theme.colors?.ctaFg || "#09122a");
        root.setProperty("--font", theme.font || "Inter, system-ui");

        const title = document.getElementById("title");
        const subtitle = document.getElementById("subtitle");
        const cta = document.getElementById("cta");
        title.textContent = theme.title || "Hello ðŸ‘‹";
        subtitle.textContent = theme.subtitle || "Welcome!";
        cta.textContent = theme.cta?.text || "Learn more";
        cta.href = normalizeHttpUrl(theme.cta?.url || "#");

        // Set preferred vh (CSS will clamp height anyway)
        const vh = computeMediaVh(theme);
        root.setProperty("--media-h", `${vh}vh`);

        // Render media
        const media = document.getElementById("media");
        media.innerHTML = "";
        const onReadyReposition = () => {
          // Reposition overlay once media dimensions are known
          const evt = new Event("media-ready");
          media.dispatchEvent(evt);
        };

        if (theme.media?.kind === "image" && theme.media.data) {
          const img = document.createElement("img");
          img.src = theme.media.data;
          img.alt = theme.media.alt || "";
          img.addEventListener("load", onReadyReposition, { once: true });
          media.appendChild(img);
        } else if (theme.media?.kind === "video" && theme.media.data) {
          const v = document.createElement("video");
          v.src = theme.media.data;
          v.autoplay = true;
          v.loop = true;
          v.muted = true;
          v.playsInline = true;
          v.controls = false;
          v.addEventListener("loadedmetadata", onReadyReposition, {
            once: true,
          });
          media.appendChild(v);
        } else {
          media.innerHTML = '<div class="muted">No media in theme.</div>';
        }
      }

      function renderQRTo(host, text, size, fg = "#000000", bg = "#ffffff00") {
        host.innerHTML = "";
        const c = document.createElement("canvas");
        c.width = c.height = Math.max(64, size || 160);
        if (window.QRCode && QRCode.toCanvas) {
          QRCode.toCanvas(c, String(text || ""), {
            errorCorrectionLevel: "medium",
            color: { dark: fg, light: bg },
            width: c.width,
            margin: 0,
          });
          host.appendChild(c);
          return;
        }
        const img = new Image();
        img.width = img.height = c.width;
        img.crossOrigin = "anonymous";
        const hex = (x) => String(x || "#000").replace("#", "");
        img.src =
          "https://api.qrserver.com/v1/create-qr-code/?" +
          `size=${c.width}x${c.height}&ecc=M&color=${hex(fg)}&bgcolor=${hex(
            "ffffff"
          )}` +
          `&data=${encodeURIComponent(String(text || ""))}`;
        host.appendChild(img);
      }

      function placeOverlay(theme, link) {
        const ov = theme?.settings?.overlay;
        if (!ov || ov.show === false) return;

        const media = document.getElementById("media");
        if (!media) return;

        const box = document.createElement("div");
        box.className = "qr-overlay";
        box.style.opacity = String(ov.opacity ?? 1);
        const size = Math.max(64, ov.size || 160);
        box.style.width = box.style.height = size + "px";

        // Prefer dynamic link destination; else CTA; else current page
        const dest = normalizeHttpUrl(
          link?.url || theme?.cta?.url || location.href
        );

        const inner = document.createElement("div");
        box.appendChild(inner);
        media.appendChild(box);

        function positionBox() {
          const pad = 16;
          const W = media.clientWidth;
          const H = media.clientHeight;
          let x = ov.x ?? pad,
            y = ov.y ?? pad;
          if (ov.pos !== "custom") {
            const map = {
              "top-left": { x: pad, y: pad },
              "top-right": { x: W - size - pad, y: pad },
              "bottom-left": { x: pad, y: H - size - pad },
              "bottom-right": { x: W - size - pad, y: H - size - pad },
            };
            const p = map[ov.pos] || map["bottom-right"];
            x = p.x;
            y = p.y;
          }
          box.style.left = x + "px";
          box.style.top = y + "px";
        }

        // Initial position + render QR
        positionBox();
        renderQRTo(inner, dest, size, "#000000", "#ffffff00");

        // Reposition after media is ready and on resize
        media.addEventListener("media-ready", () => positionBox());
        window.addEventListener("resize", () => {
          if ((ov.pos || "") !== "custom") positionBox();
        });
      }

      // Redirect countdown with optional Skip
      function resolveLink(link, theme) {
        const note = document.getElementById("note");
        if (!link || !link.url) {
          note.textContent = "";
          return;
        }

        const dest = normalizeHttpUrl(link.url);
        const delay = Number(theme?.settings?.redirectDelay ?? 0);
        const showSkip = theme?.settings?.showSkip ?? true;
        const skipText = theme?.settings?.skipText || "Skip now";

        const parts = [];
        if (delay > 0) {
          parts.push(
            `Redirecting to <span class="muted">${dest}</span> in <b id="sec">${delay}</b>sâ€¦`
          );
        } else {
          parts.push(`Destination: <span class="muted">${dest}</span>`);
        }
        if (showSkip)
          parts.push(
            `<a href="#" id="skipNow" class="cta" style="padding:6px 10px; margin-left:8px">${skipText}</a>`
          );
        parts.push(
          `<a href="#" id="stay" class="muted" style="margin-left:8px">Stay here</a>`
        );
        note.innerHTML = parts.join(" ");

        let timerId = null;
        if (delay > 0) {
          let s = delay;
          timerId = setInterval(() => {
            s--;
            const secEl = document.getElementById("sec");
            if (secEl) secEl.textContent = Math.max(0, s);
            if (s <= 0) {
              clearInterval(timerId);
              location.assign(dest);
            }
          }, 1000);
        }

        document.getElementById("skipNow")?.addEventListener("click", (e) => {
          e.preventDefault();
          if (timerId) clearInterval(timerId);
          location.assign(dest);
        });
        document.getElementById("stay")?.addEventListener("click", (e) => {
          e.preventDefault();
          if (timerId) clearInterval(timerId);
          note.textContent = "";
        });
      }

      (async function start() {
        const { themes, links } = await loadData();
        const link = linkId ? links.find((l) => l.id === linkId) : null;

        let chosenTheme = null;

        // If the themeId in the URL looks numeric, try Supabase first
        if (isNumericId(themeId) && window.sb) {
          try {
            const { data, error } = await sb
              .from("themes")
              .select("*")
              .eq("id", Number(themeId))
              .single();
            if (!error && data) chosenTheme = data;
          } catch {}
        }

        // Fallbacks: linkâ€™s themeId or local themes (legacy/local use)
        if (!chosenTheme) {
          const fallId = themeId || link?.themeId || "";
          chosenTheme =
            themes.find((t) => String(t.remoteId ?? t.id) === String(fallId)) ||
            null;
        }

        applyTheme(chosenTheme);
        if (link) resolveLink(link);
      })();
    </script>
  </body>
</html>
